COMPILER Tastier

/*
  First, let's declare all the types we're going to use.
*/

  enum TastierType : int {   // types for variables
    Undefined,
    Integer,
    Boolean, 
    String
  };

  enum TastierKind : int {  // kinds of symbol
    Var,
    Proc,
    Const,
    Array,
    Struct,
    ConstArray
  };

/*
  You'll notice some type aliases, such as the one just below, are commented
  out. This is because C# only allows using-alias-directives outside of a
  class, while class-inheritance directives are allowed inside. So the
  snippet immediately below is illegal in here. To complicate matters
  further, the C# runtime does not properly handle class-inheritance
  directives for Tuples (it forces you to write some useless methods). For
  these reasons, the type aliases which alias Tuples can be found in
  Parser.frame, but they're documented in this file, with the rest.
*/

  //using Symbol = System.Tuple<string, int, int, int, int>;

/*
  A Symbol is a name with a type and a kind. The first int in the
  tuple is the kind, and the second int is the type. We'll use these to
  represent declared names in the program.

  For each Symbol which is a variable, we have to allocate some storage, so
  the variable lives at some address in memory. The address of a variable on
  the stack at runtime has two components. The first component is which
  stack frame it's in, relative to the current procedure. If the variable is
  declared in the procedure that's currently executing, then it will be in
  that procedure's stack frame. If it's declared in the procedure that
  called the currently active one, then it'll be in the caller's stack
  frame, and so on. The first component is the offset that says how many
  frames up the chain of procedure calls to look for the variable. The
  second component is simply the location of the variable in the stack frame
  where it lives.

  The third int in the symbol is the stack frame on which the variable
  lives, and the fourth int is the index in that stack frame. Since
  variables which are declared in the global scope aren't inside any
  function, they don't have a stack frame to go into. In this compiler, our
  convention is to put these variables at an address in the data memory. If
  the variable was declared in the global scope, the fourth field in the
  Symbol will be zero, and we know that the next field is an address in
  global memory, not on the stack.

  Procedures, on the other hand, are just sets of instructions. A procedure
  is not data, so it isn't stored on the stack or in memory, but is just a
  particular part of the list of instructions in the program being run. If
  the symbol is the name of a procedure, we'll store a -1 in the address
  field (5).

  When the program is being run, the code will be loaded into the machine's
  instruction memory, and the procedure will have an address there. However,
  it's easier for us to just give the procedure a unique label, instead of
  remembering what address it lives at. The assembler will take care of
  converting the label into an address when it encounters a JMP, FJMP or
  CALL instruction with that label as a target.

  To summarize:
    * Symbol.Item1 -> name
    * Symbol.Item2 -> kind
    * Symbol.Item3 -> type
    * Symbol.Item4 -> stack frame pointer
    * Symbol.Item5 -> variable's address in the stack frame pointed to by
                      Item4, -1 if procedure
*/

  class Scope : Stack<Symbol> {}

/*
  A scope contains a stack of symbol definitions. Every time we come across
  a new local variable declaration, we can just push it onto the stack. We'll
  use the position of the variable in the stack to represent its address in
  the stack frame of the procedure in which it is defined. In other words, the
  variable at the bottom of the stack goes at location 0 in the stack frame,
  the next variable at location 1, and so on.
*/

  //using Instruction = Tuple<string, string>;
  class Program : List<Instruction> {}

/*
  A program is just a list of instructions. When the program is loaded into
  the machine's instruction memory, the instructions will be laid out in the
  same order that they appear in this list. Because of this, we can use the
  location of an instruction in the list as its address in instruction memory.
  Labels are just names for particular locations in the list of instructions
  that make up the program.

  The first component of all instructions is a label, which can be empty.
  The second component is the actual instruction itself.

  To summarize:
    * Instruction.Item1 -> label
    * Instruction.Item2 -> the actual instruction, as a string
*/

Stack<Scope> openScopes = new Stack<Scope>();
Scope externalDeclarations = new Scope();

/*
  Every time we encounter a new procedure declaration in the program, we want
  to make sure that expressions inside the procedure see all of the variables
  that were in scope at the point where the procedure was defined. We also
  want to make sure that expressions outside the procedure do not see the
  procedure's local variables. Every time we encounter a procedure, we'll push
  a new scope on the stack of open scopes. When the procedure ends, we can pop
  it off and continue, knowing that the local variables defined in the
  procedure cannot be seen outside, since we've popped the scope which
  contains them off the stack.
*/

Program program = new Program();

Program prevprogram;
List<Program> updateActionList = new List<Program> ();

// start of memory for strings or arrays
int statAddr=4090;

int startAStructArray=4096;
// this is to avoid clashes with item 5

Program header = new Program(); //
Dictionary <int ,List<int>> arrSymbolInfo=new Dictionary <int ,List<int>> ();
 
int globalDec=0;
 
 
Program tmpProgram ; // used for temporarily storing instructions
 
// When a procedure is declared with 
Dictionary <String ,List<Symbol>> procParamInfo=new Dictionary <String ,List<Symbol>> ();
 
Dictionary <String ,List<Symbol>> structInfo =new Dictionary <String ,List<Symbol>> ();

//Stores the information of the instance of a struct. This was done to avoid clashes with instances of different structs that have the same name 
// It also makes the code more readable 
Dictionary <int ,List<Symbol>> structInstanceInfo =new Dictionary <int ,List<Symbol>> ();
 

Stack<string> openProcedureDeclarations = new Stack<string>();

/*
  In order to implement the "shadowing" of global procedures by local procedures
  properly, we need to generate a label for local procedures that is different
  from the label given to procedures of the same name in outer scopes. See the
  test case program "procedure-label-shadowing.TAS" for an example of why this
  is important. In order to make labels unique, when we encounter a non-global
  procedure declaration called "foo" (for example), we'll give it the label
  "enclosingProcedureName$foo" for all enclosing procedures. So if it's at
  nesting level 2, it'll get the label "outermost$nextoutermost$foo". Let's
  make a function that does this label generation given the set of open
  procedures which enclose some new procedure name.
*/

string generateProcedureName(string name) {
  if (openProcedureDeclarations.Count == 0) {
    return name;
  } else {
    string temp = name;
    foreach (string s in openProcedureDeclarations) {
      temp = s + "$" + temp;
    }
    return temp;
  }
}

/*
  We also need a function that figures out, when we call a procedure from some
  scope, what label to call. This is where we actually implement the shadowing;
  the innermost procedure with that name should be called, so we have to figure
  out what the label for that procedure is.
*/

string getLabelForProcedureName(int lexicalLevelDifference, string name) {
  /*
     We want to skip <lexicalLevelDifference> labels backwards, but compose
     a label that incorporates the names of all the enclosing procedures up
     to that point. A lexical level difference of zero indicates a procedure
     defined in the current scope; a difference of 1 indicates a procedure
     defined in the enclosing scope, and so on.
  */
  int numOpenProcedures = openProcedureDeclarations.Count;
  int numNamesToUse = (numOpenProcedures - lexicalLevelDifference);
  string theLabel = name;

  /*
    We need to concatenate the first <numNamesToUse> labels with a "$" to
    get the name of the label we need to call.
  */

  var names = openProcedureDeclarations.Take(numNamesToUse);

  foreach (string s in names) {
      theLabel = s + "$" + theLabel;
  }

  return theLabel;
}

Stack<string> openLabels = new Stack<string>();
int labelSeed = 0;

string generateLabel() {
  return "L$"+labelSeed++;
}

/*
  Sometimes, we need to jump over a block of code which we're about to
  generate (for example, at the start of a loop, if the test fails, we have
  to jump to the end of the loop). Because it hasn't been generated yet, we
  don't know how long it will be (in the case of the loop, we don't know how
  many instructions will be in the loop body until we actually generate the
  code, and count them). In this case, we can make up a new label for "the
  end of the loop" and emit a jump to that label. When we get to the end of
  the loop, we can put the label in, so that the jump will go to the
  labelled location. Since we can have loops within loops, we need to keep
  track of which label is the one that we are currently trying to jump to,
  and we need to make sure they go in the right order. We'll use a stack to
  store the labels for all of the forward jumps which are active. Every time
  we need to do a forward jump, we'll generate a label, emit a jump to that
  label, and push it on the stack. When we get to the end of the loop, we'll
  put the label in, and pop it off the stack.
*/

Symbol _lookup(Scope scope, string name) {
  foreach (Symbol s in scope) {
      if (s.Item1 == name) {
        return s;
      }
  }
  return null;
}
string  getScope(int scopes){
  if(scopes<=1){
    return " Global ";
  }
  else {
    return " Local";
  }
}
 

int getIndex( string name,List<Symbol> syms){
   
  
  for (int i=0; i<syms.Count;i++){
    if(syms[i].Item1==name){
      return i;
    }

    } 
    return -1; 
  }
  
  

void print(string name, int scopes,TastierType type,int addr){
  string scope="";
  addr-=1;
  if(scopes<=1){
    scope= " Global ";
  }
  else {
    scope= " Local";
  }
    
}
Symbol lookup(Stack<Scope> scopes, string name) {
  int stackFrameOffset = 0;
  int variableOffset = 0;
  
  foreach (Scope scope in scopes) {
    foreach (Symbol s in scope) {
    
      if (s.Item1 == name) {
        return s;
      }
      else {
        variableOffset += 1;
      }
    }
    stackFrameOffset += 1;
    variableOffset = 0;
  }
  return null; // if the name wasn't found in any open scopes.
}
// This method is used to store the local strings 
int findAddr(Stack<Scope> scopes) {
  int count = 0;
  foreach (Scope scope in scopes) {
    foreach (Symbol s in scope) {
      if (s.Item3 == (int)TastierType.String || s.Item4 == 0) {
        count++;
      }
    }
  }
  return count; // return the number of global / string Consts / variables...
}

/*
  You may notice that when we use a LoadG or StoG instruction, we add 3 to
  the address of the item being loaded or stored. This is because the
  control and status registers of the machine are mapped in at addresses 0,
  1, and 2 in data memory, so we cannot use those locations for storing
  variables. If you want to load rtp, rbp, or rpc onto the stack to
  manipulate them, you can LoadG and StoG to those locations.
*/

/*--------------------------------------------------------------------------*/

CHARACTERS
letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  white_space = ' '.
TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.
  String ='"'{letter  | digit| white_space}'"'.
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*------------------------------------------------------------------------*/

AddOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Add"); .)
  ( '+' 
  | '-'                         (.  inst = new Instruction("", "Sub"); .)
  ).

/*------------------------------------------------------------------------*/

Expr<out TastierType type>      (.  TastierType type1; Instruction inst; .)
= SimExpr<out type>
  [ RelOp<out inst>
    SimExpr<out type1>          (.
                                    if (type != type1) {
                                      SemErr("incompatible types");
                                    }
                                    else {
                                      program.Add(inst);
                                      type = TastierType.Boolean;
                                    }
                                .)
  ].

/*------------------------------------------------------------------------*/

ArrayAccess<Symbol sym>  (. List<int> dimens;   int noD=0; TastierType type;.)
=   
         '['                         (.
                                           
                                           program.Add(new Instruction("", "LoadG " + (sym.Item5+3))); // load the start of the address
                       
                                          dimens =arrSymbolInfo[sym.Item5];  
                                    .)
              Expr<out type>        (. 
                                         
                                          
                                         if(type!=TastierType.Integer){
                                          SemErr(" cannot index using this type");  
                                         }
                                          noD++;


                                     .)
           ']'
           {'['                     (.program.Add(new Instruction("", "Const "  +dimens[noD]));
                                      program.Add(new Instruction("", "Mul")); .)  
              Expr<out type>        (. 
                                         if(type!=TastierType.Integer){
                                          SemErr(" cannot index using this type");  
                                         }
                                         
                                         program.Add(new Instruction("", "Add")); 
                                          noD++; 
                                     .)
       
           ']'}(.program.Add(new Instruction("", "Sub"));.)           // subtract offset to index 
.   
Factor<out TastierType type>    (.  int n; Symbol sym; string name; List<int> dimens;   int noD=0;   string name2; List <Symbol> symbols; int addr;TastierType strucElemType=TastierType.Undefined;.)
=                               (.  type = TastierType.Undefined;Symbol structSym=null; .)
  ( Ident<out name>            (. 
                                  sym = lookup(openScopes, name); 
                                  if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }
                               .)
   ["." Ident<out name2>        (.   

                                  

                                   if(!structInstanceInfo.TryGetValue(sym.Item5,out symbols)){
                                          SemErr("Incorrect struct name");

                                       }
                                  if (sym.Item2 !=(int)TastierKind.Struct) {
                                      SemErr("Struct expected ");
                                    }

                                   addr= getIndex(name2,symbols);
                                   if(addr==-1){
                                     SemErr("reference to undefined ident in the struct" + name2);
                                   }
                                   strucElemType=(TastierType)symbols[addr].Item3;
                                   

                                   program.Add(new Instruction("", "LoadG " + (sym.Item5+3))); // load the pointer of the struct
                                   program.Add(new Instruction("", "Const " + (addr)));        // subtract the offset
                                   program.Add(new Instruction("", "Sub" )); 
                                  
                                   structSym=symbols[addr]; 
                                .) 
    ]
              [
                                  '['                (.

                                                       if (structSym!=null &&structSym.Item2==(int)TastierKind.Array){
                                                          program.Add(new Instruction("", "LoadT"));// new instruction which loads what is on the top off stack
 
                                                          dimens =arrSymbolInfo[structSym.Item5]; 
                                                      
                                                        }
                                                        else{

                                                           program.Add(new Instruction("", "LoadG " + (sym.Item5+3))); // load the start of the address
                       
                                                           dimens =arrSymbolInfo[sym.Item5];  
                                                        }
                                                              
                                                      .)
                                Expr<out type>        (.  
                                                           if(type!=TastierType.Integer){
                                                            SemErr(" cannot index using this type");  
                                                           }
                                                            noD++;


                                                       .)
                             ']'
                             {'['                     (.program.Add(new Instruction("", "Const "  +dimens[noD]));
                                                        program.Add(new Instruction("", "Mul")); .)  
                                Expr<out type>        (. 
                                                           if(type!=TastierType.Integer){
                                                            SemErr(" cannot index using this type");  
                                                           }
                                                           
                                                           program.Add(new Instruction("", "Add")); 
                                                            noD++; 
                                                       .)
                         
                             ']'}(.program.Add(new Instruction("", "Sub"));.)     
              ]
    
         
                      
     
  
                                   (.
                                    bool isExternal = false; //CS3071 students can ignore external declarations, since they only deal with compilation of single files.
                                    sym = lookup(openScopes, name); 
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }

                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }
                                    else { 
                                      type = (TastierType)sym.Item3;
                                      int offset=0;
                                      if ((TastierKind)sym.Item2 == TastierKind.Var ||(TastierKind)sym.Item2 == TastierKind.Const ||(TastierKind)sym.Item2 == TastierKind.Array
                                        ||(TastierKind)sym.Item2 == TastierKind.Struct) {
                                           
                                          if (sym.Item4 == 0) {
                                                  // calculating the address of the item
                                                  offset = sym.Item5+3;
                                             
                                              if ((TastierKind)sym.Item2 == TastierKind.Array) {
                                                  
                                                  
                                                   
                                                  
                                                   program.Add(new Instruction("", "LoadT"));// new instruction which loads what is on the top off stack
                                               }
                                               else if((TastierKind)sym.Item2 == TastierKind.Struct){
                                                 type= strucElemType;
                                                 program.Add(new Instruction("", "LoadT"));// new instruction which loads what is on the top off stack
                                                
                                                } else {
                                              
                                                  program.Add(new Instruction("", "LoadG " + (offset)));
                                               }
                                        } 
                                        else { 
                                                int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                                program.Add(new Instruction("", "Load " + lexicalLevelDifference + " " + sym.Item5));
                                             
                                        }
                                      } 
                                      else SemErr("variable expected");
                                    }
                                .)
  
  | number                      (.
                                    n = Convert.ToInt32(t.val);
                                  
                                    program.Add(new Instruction("", "Const " + n));
                                    type = TastierType.Integer;
                                .)
  
  | '-'
    Factor<out type>            (.
                                    if (type != TastierType.Integer) {
                                      SemErr("integer type expected");
                                      type = TastierType.Integer;
                                    }
                                    program.Add(new Instruction("", "Neg"));
                                    program.Add(new Instruction("", "Const 1"));
                                    program.Add(new Instruction("", "Add"));
                                .)
  | "true"                      (.  program.Add(new Instruction("", "Const " + 1)); type = TastierType.Boolean; .)
  | "false"                     (.  program.Add(new Instruction("", "Const " + 0)); type = TastierType.Boolean; .)
  ).

/*------------------------------------------------------------------------*/

Ident<out string name>
= ident                         (.  name = t.val; .).

/*------------------------------------------------------------------------*/

MulOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Mul"); .)
  ( '*'
  | '/'                         (.  inst = new Instruction("", "Div"); .)
  ).
 
/*------------------------------------------------------------------------*/
/* This production deals with the parameters in a procedure. It stores the info of the params in procParamInfo so when we are passing 
parameters, will know its kind, type ,etc
*/ 
Param<String name> (.TastierType type; string name2,name3; Symbol sym;Scope currentScope = openScopes.Peek();List <Symbol> paramSyms= new List <Symbol>();
                        List<int> dimnS = new List<int> (); tmpProgram = new Program();
                       List<Symbol> attr;.)
='('    [ 
          ("Struct" Ident<out name3> Ident<out name2>    (.   
                                                if(!structInfo.TryGetValue(name3,out attr)){
                                                SemErr("Incorrect struct name");
                                                }
                                             
                                                sym=new Symbol(name2, (int)TastierKind.Struct, (int)TastierType.Undefined, 0,  globalDec);
                                               

                                                structInstanceInfo.Add(sym.Item5,attr); //storing info about the struct  
                                       .)

         |Type<out type> 
          Ident<out name2>        (.        
                                      sym=new Symbol(name2, (int)TastierKind.Var, (int)type, 0,  globalDec);
                                  .)  
          [  '[' number                  (. 
                                             sym=new Symbol(name2, (int)TastierKind.Array, (int)type, 0,  globalDec );   
                                            dimnS.Add(Convert.ToInt32(t.val));

                                         .)
           ']'
           {'['number                  (.   
                                            dimnS.Add(Convert.ToInt32(t.val));

                                         .)           
           ']'}
                                     (.    
                                           
                                          arrSymbolInfo.Add(globalDec,dimnS); 

                                           
                                     .)
          ]) (.  
                                         globalDec++; 
                                         paramSyms.Add(sym);
                                         tmpProgram.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                         currentScope.Push(sym); 
                                     .)
          
          

         
          { ','
             ("Struct" Ident<out name3> Ident<out name2>    (.   
                                                if(!structInfo.TryGetValue(name3,out attr)){
                                                SemErr("Incorrect struct name");
                                                }
                                             
                                                sym=new Symbol(name2, (int)TastierKind.Struct, (int)TastierType.Undefined, 0,  globalDec);
                                              
                                                structInstanceInfo.Add(sym.Item5,attr); //storing info about the struct  
                                       .)

           |Type<out type>  Ident<out name2>      (.    sym=new Symbol(name2, (int)TastierKind.Var, (int)type, 0,  globalDec);  .) 

            [  '[' number              (.    
                                            dimnS.Add(Convert.ToInt32(t.val)); 
                                      .)
           ']'
           {'['number                  (.    
                                            dimnS.Add(Convert.ToInt32(t.val)); 
                                       .)           
           ']'}
                                       (.    
                                            sym=new Symbol(name2, (int)TastierKind.Array, (int)type, 0,  globalDec ); 
                                            arrSymbolInfo.Add(globalDec,dimnS);  
                                      .)
           ] )                         (. 
                                            globalDec++; 
                                            paramSyms.Add(sym); 
                                            currentScope.Push(sym); 
                                            tmpProgram.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                      .)
             
                                   
 
            }  
                
    ]         
      ')'  (.     
                                          procParamInfo.Add(name,paramSyms) ; 
                                    .)               
             
.
/*------------------------------------------------------------------------*/
ProcDecl                        (.  string name; string label; Scope currentScope = openScopes.Peek(); int enterInstLocation = 0; bool external = false;   .)
= "void"
  Ident<out name>               (.
                                    currentScope.Push(new Symbol(name, (int)TastierKind.Proc, (int)TastierType.Undefined, openScopes.Count, -1));
                                    openScopes.Push(new Scope());
                                    currentScope = openScopes.Peek();
                                    label = generateProcedureName(name);
                                .)
  Param<label>    

  '{'                           (.
                                   
                                    
                                   
                                   
                                    openProcedureDeclarations.Push(name);
                                    program.Add(new Instruction(label, "Nop"));
                                    if (tmpProgram.Count!=0){
                                       program.Add(new Instruction("", "StoG " + (4091)));// temporarily storing the return address and lexical difference
                                    program.Add(new Instruction("", "StoG " + (4092)));
                                    program.AddRange(tmpProgram);
                                    program.Add(new Instruction("", "LoadG " + (4092)));  //pushing back onto stack the return address and lexical difference
                                    program.Add(new Instruction("", "LoadG " + (4091)));  
                                    }

                                     
                                    program.Add(new Instruction("", "Enter 0"));
                                     enterInstLocation = program.Count - 1;
                                    /*
                                      Enter is supposed to have as an
                                      argument the next free address on the
                                      stack, but until we know how many
                                      local variables are in this procedure,
                                      we don't know what that is. We'll keep
                                      track of where we put the Enter
                                      instruction in the program so that
                                      later, when we know how many spaces on
                                      the stack have been allocated, we can
                                      put the right value in.
                                    */
                                .)

  {StructIntial|ConstDecl| VarDecl<external> | Stat |  (.
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    /*
                                      We need to jump over procedure
                                      definitions because otherwise we'll
                                      execute all the code inside them!
                                      Procedures should only be entered via
                                      a Call instruction.
                                    */
                                .)
    ProcDecl                    (. program.Add(new Instruction(openLabels.Pop(), "Nop")); .)
  }
  '}'                           (.
                                    program.Add(new Instruction("", "Leave"));
                                    program.Add(new Instruction("", "Ret"));
                                    openScopes.Pop();
                                    // now we can generate the Enter instruction properly
                                    program[enterInstLocation] =
                                      new Instruction("", "Enter " +
                                                      ( currentScope.Count(s => (s.Item2 == (int)TastierKind.Var)
                                           || (s.Item2 == (int)TastierKind.Const)|| (s.Item2 == (int)TastierKind.Array) ||(s.Item2 == (int)TastierKind.Struct))));
                                    openProcedureDeclarations.Pop();
                                .).

/*------------------------------------------------------------------------*/

RelOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Equ"); .)
  ( '='
  | '<'                         (.  inst = new Instruction("", "Lss"); .)
  | "!="                        (.  inst = new Instruction("", "NotEqu"); .)
  | "<="                        (.  inst = new Instruction("", "LssEqu"); .)
  | '>'                         (.  inst = new Instruction("", "Gtr"); .)
  | ">="                         (.  inst = new Instruction("", "GtrEqu"); .)
  ).
/*------------------------------------------------------------------------*/

SimExpr<out TastierType type>   (.  TastierType type1; Instruction inst; .)
= Term<out type>
  { AddOp<out inst>
    Term<out type1>             (.
                                    if (type != TastierType.Integer || type1 != TastierType.Integer) {
                                      SemErr("integer type expected");
                                    }
                                    program.Add(inst);
                                .)
  }.

/*------------------------------------------------------------------------*/
// The intial action and update actions
InitialAction                         (.  TastierType type; string name; Symbol sym;bool isExternal = false;  .)
= Ident<out name>               (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }
                                .)
   ":="                         (.
                           
                                    if ((TastierKind)sym.Item2 != TastierKind.Var&&(TastierKind)sym.Item2 == TastierKind.Array  ) {
                                      SemErr("cannot assign to non-variable");
                                    }
                                .)
  
   Expr<out type> 
    (  ['?'                  
         (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                  
                                .)
    Expr<out type>         (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    /*
                                       If we got into the "if", we need to
                                       jump over the "else" so that it
                                       doesn't get executed.
                                    */
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)
    
     ':' Expr<out type>         (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .)
     ]
     (.                            
                                    if (type != (TastierType)sym.Item3) {
                                      SemErr("incompatible types");
                                    }
                                    if (sym.Item4 == 0) {
                                      if (isExternal) {
                                        program.Add(new Instruction("", "StoG " + sym.Item1));
                                        // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                      } else {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                        
                                      }
                                    }
                                    else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
          .)
    )';'.
  
/*------------------------------------------------------------------------*/
UpdateAction                     (.  TastierType type; string name; Symbol sym; prevprogram= program; program=new Program(); .)
= Ident<out name>                (.
                                    sym = lookup(openScopes, name);
                                     
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }
                                .)
   ":="                         (.
                           
                                    if ((TastierKind)sym.Item2 != TastierKind.Var ) {
                                      SemErr("cannot assign to non-variable");
                                    }
                                .) 
   Expr<out type> 
    (  ['?'                  
         (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                  
                                .)
    Expr<out type>         (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    /*
                                       If we got into the "if", we need to
                                       jump over the "else" so that it
                                       doesn't get executed.
                                    */
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)
    
     ':' Expr<out type>         (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .) 
                           
     ]
     (.                            
                                    if (type != (TastierType)sym.Item3) {
                                      SemErr("incompatible types");
                                    }
                                    if (sym.Item4 == 0) {
                                      
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                        
                                      
                                    }
                                    else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
          .)
    )';'(.
            updateActionList.Add(program); // add instructions 
            program=prevprogram;  // change the pointer to the current program
        .).

/*------------------------------------------------------------------------*/
Stat                            (.  TastierType type,type2,strucElemType=TastierType.Undefined;  List<int> dimens;    int noD=0,offset,addr=0; Symbol sym,sym3; bool external = false;
                                    bool isExternal = false;  string name2,name,name1;  int index=0; List <Symbol> symbols; TastierKind strucElemKind;
                                    .) 
= Ident<out name>               (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }
                                .)
 ["." Ident<out name2>        (.   

                                 sym = lookup(openScopes, name); 
                                  if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }
                                   symbols= structInstanceInfo[sym.Item5]; 
                                  
                                   offset= getIndex(name2,symbols);

                                   strucElemType=(TastierType)symbols[offset].Item3;
                                   strucElemKind=(TastierKind)symbols[offset].Item2;

                                   program.Add(new Instruction("", "LoadG " + (sym.Item5+3))); // load the pointer of the struct
                                   program.Add(new Instruction("", "Const " + (offset)));        // subtract the offset
                                   program.Add(new Instruction("", "Sub" )); 
                                  
                                   sym3=symbols[offset];
                                   
                                .) 

 ]
 [
    '['                (. 
                              if(sym.Item2==(int)TastierKind.Struct&& sym3.Item2==(int)TastierKind.Array){
                                   program.Add(new Instruction("", "LoadT"));// new instruction which loads what is on the top off stack
                                   dimens =arrSymbolInfo[sym3.Item5]; 
                          
                                  }
                              else{
                                    program.Add(new Instruction("", "LoadG " + (sym.Item5+3))); // load the start of the address st
                                    dimens =arrSymbolInfo[sym.Item5];  
                                  }                         

                                                                                         
                      .)
                      Expr<out type>        (.  
                                              if(type!=TastierType.Integer){
                                                SemErr(" cannot index using this type");  
                                               }
                                                 noD++;

                                          .)
                             ']'
                     {'['        (.program.Add(new Instruction("", "Const "  +dimens[noD]));
                                                       
                                   program.Add(new Instruction("", "Mul")); .)  
                       Expr<out type>        (. 
                                               if(type!=TastierType.Integer){
                                                 SemErr(" cannot index using this type");  
                                                  }
                                                   program.Add(new Instruction("", "Add")); 
                                                   noD++; 
                                              .)
                         
                    ']'}(.program.Add(new Instruction("", "Sub"));.)     
    ]
  
  
  ( ":="                         (.
                           
                                    if ((TastierKind)sym.Item2 != TastierKind.Var &&(TastierKind)sym.Item2 != TastierKind.Array &&(TastierKind)sym.Item2 != TastierKind.Struct) {

                                      SemErr("cannot assign to non-variable");
                                    }
                                .)
  (
    | Expr<out type> 
    (  ['?'                  
         (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                  
                                .)
    Expr<out type>         (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop"); 
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)
    
     ':' Expr<out type>         (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .) 
     ]
     (.                            
                                    if (type != (TastierType)sym.Item3 && strucElemType!=type) {
                                      SemErr("incompatible types");
                                    }
                                    if (sym.Item4 == 0) {
                                      if (isExternal) {
                                        program.Add(new Instruction("", "StoG " + sym.Item1));
                                        // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                      } 
                                      else if (TastierKind.Array == (TastierKind)sym.Item2 ||TastierKind.Struct == (TastierKind)sym.Item2){

                                       
 
                                        program.Add(new Instruction("", "StoT"));// new instruction which stores what is on the top off stack
                                      }
                                      else {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                       
                                      }

                                    }
                                    else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
          .)
    )
    | Str<sym,out type>                 
                                 
  
  
) ';'

  
  | '('(.
         int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4);
         string procedureLabel = getLabelForProcedureName(lexicalLevelDifference, sym.Item1);
         List <Symbol> paramSyms =procParamInfo[procedureLabel];//  find parameters of that particular procedure
         tmpProgram=new Program();
          
      .)
       [   Ident<out name1>   (.
                                   
                                 
                                    
                                      Symbol paramToPass = lookup(openScopes, name1);  // parameter in the function call

                                     
                                      
                                      if(index<paramSyms.Count){
                                         int addr2= paramSyms[index].Item5;

                                          Symbol curParam=paramSyms[index];
                                          
                                        if(paramToPass.Item4==0 && paramToPass.Item2==curParam.Item2 && curParam.Item3==paramToPass.Item3
                                           && curParam.Item2==(int)TastierKind.Struct){ // if their are the same type and kind and also global 
                                             tmpProgram.Add(new Instruction("", "LoadG " + (paramToPass.Item5+3)));

                                              structInstanceInfo[curParam.Item5] =structInstanceInfo[paramToPass.Item5];// passing the struct info
                                            
                                          }
                                         else if(paramToPass.Item4==0 && paramToPass.Item2==curParam.Item2 && curParam.Item3==paramToPass.Item3){ // if their are the same type and kind and also global 
                                             tmpProgram.Add(new Instruction("", "LoadG " + (paramToPass.Item5+3)));
                                             
                                          }
                                          else if(paramToPass.Item4!=0 && paramToPass.Item2==curParam.Item2 && curParam.Item3==paramToPass.Item3) { 
                                               int lexicalLevel  = Math.Abs(openScopes.Count - paramToPass.Item4)-1; // if local variables
                                               tmpProgram.Add(new Instruction("", "Load " + lexicalLevel + " " + paramToPass.Item5));
                                                  
                                          }
                                          else{
                                             SemErr("Type mismatch");
                                          }
                                          
                                           index++;
                                      }
                                      else{
                                         SemErr("Incorrect number of parameters");
                                      }
                                     
                                     
                                .) 
            { ","Ident<out name1>   (.
                                   
                                    
                                    
                                       paramToPass = lookup(openScopes, name1);  // parameter in the function call

                                    
                                      
                                      if(index<paramSyms.Count){
                                         int addr2= paramSyms[index].Item5;
                                          Symbol curParam=paramSyms[index];
                                        if(paramToPass.Item4==0 && paramToPass.Item2==curParam.Item2 && curParam.Item3==paramToPass.Item3
                                           && curParam.Item2==(int)TastierKind.Struct){ // if their are the same type and kind and also global 
                                             tmpProgram.Add(new Instruction("", "LoadG " + (paramToPass.Item5+3)));

                                              structInstanceInfo[curParam.Item5] =structInstanceInfo[paramToPass.Item5];// passing the struct info
                                          

                                            
                                          }
                                         else if(paramToPass.Item4==0 && paramToPass.Item2==curParam.Item2 && curParam.Item3==paramToPass.Item3){ // if their are the same type and kind and also global 
                                             tmpProgram.Add(new Instruction("", "LoadG " + (paramToPass.Item5+3)));
                                              
                                          }
                                          else if(paramToPass.Item4!=0 && paramToPass.Item2==curParam.Item2 && curParam.Item3==paramToPass.Item3) {  // if local variables
                                               int lexicalLevel  = Math.Abs(openScopes.Count - paramToPass.Item4)-1;
                                               tmpProgram.Add(new Instruction("", "Load " + lexicalLevel + " " + paramToPass.Item5));
                                                
                                          }
                                          else{
                                             SemErr("Type mismatch");
                                          }
                                          
                                           index++;
                                      }
                                      else{
                                         SemErr("Incorrect number of parameters");
                                      }
                                     
                                     
                                .)
            }
                             (. tmpProgram.Reverse();// pushed onto stack in reverse order
                                program.AddRange(tmpProgram);

                                if(index<paramSyms.Count){
                                  SemErr("Incorrect number of parameters"+(paramSyms.Count-index)+" more required");
                                }
                              .)
         ]
    ')' ';'                   (.  if ((TastierKind)sym.Item2 != TastierKind.Proc) {
                                      SemErr("object is not a procedure");
                                    }
                                   
                                    int currentStackLevel = openScopes.Count;
                                    
                                    program.Add(new Instruction("", "Call " + lexicalLevelDifference + " " + procedureLabel));
                              .)
  )

| "if"
  '(' Expr<out type> ')'        (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                                .)
      Stat                      (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    /*
                                       If we got into the "if", we need to
                                       jump over the "else" so that it
                                       doesn't get executed.
                                    */
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)
      [ "else"
        Stat
      ]                         (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .)

| "while"                       (.  string loopStartLabel = generateLabel();
                                    openLabels.Push(generateLabel()); //second label is for the loop end
                                    program.Add(new Instruction(loopStartLabel, "Nop"));
                                .)
  '(' Expr<out type> ')'        (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); // jump to the loop end label if condition is false
                                .)
      Stat                      (.  program.Add(new Instruction("", "Jmp " + loopStartLabel));
                                    program.Add(new Instruction(openLabels.Pop(), "Nop")); // put the loop end label here
                                .)
| "for"                          
   
    '(' InitialAction                 (.  string loopStartLabel = generateLabel();
                                    openLabels.Push(generateLabel()); //second label is for the loop end
                                    program.Add(new Instruction(loopStartLabel, "Nop"));
                                .)
    UpdateAction 

     Expr<out type>  ')'    (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); // jump to the loop end label if condition is false
                                .)
      Stat                      (.
                                      //appending the update action to the original program
                                      if (updateActionList.Count !=0){
                                      int listLength=updateActionList.Count; 
                                      program.AddRange(updateActionList[listLength-1]);
                                      updateActionList.RemoveAt(listLength-1);// remove update action from the list 
                                       }
                                     
                                    program.Add(new Instruction("", "Jmp " + loopStartLabel));
                                    program.Add(new Instruction(openLabels.Pop(), "Nop")); // put the loop end label here
                                .)


| "read"
  Ident<out name> ';'           (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }

                                    if (sym.Item2 != (int)TastierKind.Var) {
                                      SemErr("variable type expected but " + sym.Item1 + " has kind " + (TastierType)sym.Item2);
                                    }

                                    if (sym.Item3 != (int)TastierType.Integer) {
                                      SemErr("integer type expected but " + sym.Item1 + " has type " + (TastierType)sym.Item2);
                                    }
                                    program.Add(new Instruction("", "Read"));

                                    if (sym.Item4 == 0) {
                                      if (isExternal) {
                                        program.Add(new Instruction("", "StoG " + sym.Item1));
                                        // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                      } else {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                       
                                      }
                                    }
                                    else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
                                .)

| "write"
  Expr<out type>             (. 
                                    if (type != TastierType.Integer&&type != TastierType.String) {
                                      SemErr("integer or string type expected");
                                    }
                                     if (type == TastierType.String) {
                                      program.Add(new Instruction("", "Print"));
                                    }
                                    else{
                                      program.Add(new Instruction("", "Write"));
                                    }
                                    
                                .)
   {',' Expr<out type> 
                                (.
                                    if (type != TastierType.Integer && type != TastierType.String) {
                                      SemErr("integer/string type expected");
                                    }
                                    if (type == TastierType.String)
                                    {
                                        program.Add(new Instruction("", "Print"));
                                    }
                                    else
                                    {
                                        program.Add(new Instruction("", "Write"));
                                    }
                                .)}
  ';'


 
| '{' { Stat | VarDecl<external> } '}'.

/*-------------------------------------------------------------------------*/

Tastier                         (.  string name; bool external = false; .)
= "program"
  Ident<out name>               (.
                                    openScopes.Push(new Scope());
                                .)
  '{'
  {ConstDecl|StructDecl  }
  {  VarDecl<external> | ProcDecl | ExternDecl }
  '}'                           (.
                                    if (openScopes.Peek().Count == 0) {
                                      Warn("Warning: Program " + name + " is empty ");
                                    }

                                    header.Add(new Instruction("", ".names " + (externalDeclarations.Count + openScopes.Peek().Count)));
                                    foreach (Symbol s in openScopes.Peek()) {
                                      if (s.Item2 == (int)TastierKind.Var ) {
                                        header.Add(new Instruction("", ".var " + ((int)s.Item3) + " " + s.Item1));
                                      }else if (s.Item2 == (int)TastierKind.Const) {
                                        header.Add(new Instruction("", ".const " + ((int)s.Item3) + " " + s.Item1));
                                      }
                                      else if (s.Item2 == (int)TastierKind.Array) {
                                        header.Add(new Instruction("", ".const " + ((int)s.Item3) + " " + s.Item1));
                                      }
                                       else if (s.Item2 == (int)TastierKind.Proc) {
                                        header.Add(new Instruction("", ".proc " + s.Item1));
                                      } else {
                                        SemErr("global item " + s.Item1 + " has no defined type");
                                      }
                                    }
                                    foreach (Symbol s in externalDeclarations) {
                                      if (s.Item2 == (int)TastierKind.Var) {
                                        header.Add(new Instruction("", ".external var " + ((int)s.Item3) + " " + s.Item1));
                                      } else if (s.Item2 == (int)TastierKind.Proc) {
                                        header.Add(new Instruction("", ".external proc " + s.Item1));
                                      } else {
                                        SemErr("external item " + s.Item1 + " has no defined type");
                                      }
                                    }
                                    header.AddRange(program);
                                    openScopes.Pop();
                                .).

/*------------------------------------------------------------------------*/

Term<out TastierType type>      (.  TastierType type1; Instruction inst; .)
= Factor<out type>
  { MulOp<out inst>
    Factor<out type1>           (.
                                    if (type != TastierType.Integer ||
                                        type1 != TastierType.Integer) {
                                      SemErr("integer type expected");
                                    }
                                    program.Add(inst);
                                .)
  }.

/*------------------------------------------------------------------------*/

Type<out TastierType type>
=                               (.  type = TastierType.Undefined; .)
 ( "int"                        (.  type = TastierType.Integer; .)
 | "bool"                       (.  type = TastierType.Boolean; .)
 | "string"                       (.  type = TastierType.String; .)
 ).
/*------------------------------------------------------------------------*/
Str<Symbol sym, out TastierType type>
=String (.
                                     
                                    string sval = (t.val).Replace("\"", ""); 

                                    int baseAddr;
                                 
                                    baseAddr = sym.Item5; 
                                   
                                     program.Add(new Instruction("", "Const " + (statAddr)));// storing the address of the string 
                              
                                     if(TastierKind.Array == (TastierKind)sym.Item2||TastierKind.Struct == (TastierKind)sym.Item2){
                                            
                                          
                                       
                                         program.Add(new Instruction("", "StoT"));// new instruction which stores what is on the top off stack
                                        
                                      }
                                    
                                      else{ 
                                           program.Add(new Instruction("", "StoG " + (baseAddr+3)));
            
                                      }

                                    program.Add(new Instruction("", "Const " + sval.Length));// storing the length of the string
                                   
                                    program.Add(new Instruction("", "StoG " + (statAddr)));
                                    
                                    
                                
                                    foreach (char c in sval)
                                    {
                                        int c_int = (int)c;
                                        program.Add(new Instruction("", "Const " + c_int));
                                         statAddr--; 
                                        program.Add(new Instruction("", "StoG " + (statAddr)));
                                      
                                    }
                                    statAddr--;
                                    
                                    type = TastierType.String;
                                .)
.
/*------------------------------------------------------------------------*/
 
StructDecl (.Symbol sym; string name; List <Symbol> symbols= new List<Symbol> ();List<int> dimnS = new List<int> (); TastierType type; string name2;.)// stores the 
= "Struct" Ident<out name>"{"
      Type<out type>
      Ident<out name2> (. sym=new Symbol(name2, (int)TastierKind.Var, (int)type, 0,  0 );// address do not  matter
                       .)
        ['['  number         (. sym = new Symbol(name2, (int)TastierKind.Array, (int)type, 0, startAStructArray); //since item5 is used to store the dimensions in the arrSymbolInfo and the dictionary
                                                                                                                 // needs unique item5 
                               startAStructArray++;
                               dimnS.Add(Convert.ToInt32(t.val));
                          .) 
        ']'
         {
           '[' number     (.dimnS.Add(Convert.ToInt32(t.val));
                          .)
           ']' 
         } (.arrSymbolInfo.Add(sym.Item5,dimnS); .)

        ] (.  symbols.Add(sym); .)
 

     { 
       ";" Type<out type>
        Ident<out name2> (. sym=new Symbol(name2, (int)TastierKind.Var, (int)type, 0,  0 );// address do not  matter
                       .)
        ['['  number         (. sym = new Symbol(name2, (int)TastierKind.Array, (int)type, 0, startAStructArray); 
                             startAStructArray++;
                             dimnS.Add(Convert.ToInt32(t.val));
                          .) 
        ']'
         {
           '[' number     (.dimnS.Add(Convert.ToInt32(t.val));
                          .)
           ']' 
         } (.arrSymbolInfo.Add(sym.Item5,dimnS); .)

        ] (.  symbols.Add(sym); .)


     }


  "}"(. structInfo[name]=symbols;.).


/*-------------------------------------------------------------------------*/
structIdentDec <int index,int structI,Symbol sym2, out Symbol symb>   (.string name1; Symbol sym;.)
= Ident<out name1> (.
                         sym = lookup(openScopes, name1);
                         if( sym.Item3!=sym2.Item3){
                           SemErr("Type mismatch");
                         }
                          
                         if(sym.Item2==sym2.Item2&&sym.Item2==(int)TastierKind.Array){
                          
                          
                           program.Add(new Instruction("", "LoadG " + (sym.Item5+3)));//load the pointer
                           program.Add(new Instruction("", "StoG " + (structI)));// store pointer in the struct space

                         }
                         else if(sym.Item2==sym2.Item2&&sym.Item2==(int)TastierKind.Var){

                           program.Add(new Instruction("", "LoadG " + (sym.Item5+3)));//load the pointer
                           program.Add(new Instruction("", "StoG " + (structI)));// store pointer in the struct space
                         }
                         else{
                          SemErr("incompatible kind in the struct");
                         }
                         symb=sym;  //used only if array , changing
.)
.


/*-------------------------------------------------------------------------*/
/* Intialising struct. When the user passes in the parameters for intialising the struct, a new struct instance is created and 
symbols related to the struct are stored in the instance dictionary. As it pass through the parameters, it updates the symbols 
so that it contains the relevant information
*/
StructIntial (.string name; string name1;string name2;List <Symbol> attr;int structI=0; TastierType type; int i=0;Symbol sym,sym1;
                 Scope currentScope = openScopes.Peek(); .)
=  "Struct" 
    Ident<out name>  
   
":=" "new" Ident<out name2> (.       
                                if(!structInfo.TryGetValue(name2,out attr)){
                                          SemErr("Incorrect struct name");
                                       }
                                     

                                        sym=new Symbol(name, (int)TastierKind.Struct, (int)TastierType.Undefined, 0, globalDec );// creating a symbol for an instance of a struct
                                       
                                        currentScope.Push(sym); 
                                       
                                        program.Add(new Instruction("", "Const " + statAddr)); // store the start address of the array
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                        globalDec++;

                                        structI=statAddr;

                                        statAddr=statAddr-attr.Count;// allocating space for the struct
                                        structInstanceInfo.Add(sym.Item5,attr);   //storing info about the struct  
                                        
.)
                                      
                                
   "("
     (
       structIdentDec<i,structI,attr[i], out sym1> (. 
                                      if(attr[i].Item2==(int)TastierKind.Array){
                                       
                                        
                                         List<Symbol> newSyms = new List<Symbol>();
                                         List<Symbol> oldSyms = structInstanceInfo[sym.Item5];// getting the old symbols associated with an instance of a struct 
                                         newSyms.AddRange( structInstanceInfo[sym.Item5]);
                                        
                                        Symbol newSym = new Symbol(attr[i].Item1, sym1.Item2, sym1.Item3, sym1.Item4, sym1.Item5); // updating the symbol of the 
                                        newSyms[i] = newSym;
                                        structInstanceInfo[sym.Item5] = newSyms;
                             
                                         
                                      }
                                      
                                       structI--;
                                       i++;
                                    .) 
      |Expr<out type> (. 
                       if((int)type!=attr[i].Item3){
                        SemErr("Type mismatch");
                       }
                       if(i>=attr.Count){
                         SemErr("Incorrect number of arguments");
                       }
                        program.Add(new Instruction("", "StoG " + (structI)));
                        structI--; 
                        i++;
                   .)
      | (. program.Add(new Instruction("", "Const " + (structI)));.)
        Str<sym,out type>  (.  
                                      if(i>=attr.Count){
                                         SemErr("Incorrect number of arguments");
                                       }
                                       
                                       structI--;
                                       i++;
                                    .)
      )
     {
        ','(   structIdentDec <i,structI,attr[i], out sym1> (. 
                                       if(attr[i].Item2==(int)TastierKind.Array){   
                                     
                                         
                                       List<Symbol> newSyms = new List<Symbol>();
                                        newSyms.AddRange( structInstanceInfo[sym.Item5]);
                                        Symbol newSym = new Symbol(attr[i].Item1, sym1.Item2, sym1.Item3, sym1.Item4, sym1.Item5);
                                        newSyms[i] = newSym;
                                        structInstanceInfo[sym.Item5] = newSyms;
                                        
                                         
                                      }
                                      
                                       structI--;
                                       i++;
                                    .) 
                  |Expr<out type> (. 
                                           if((int)type!=attr[i].Item3){
                                            SemErr("Type mismatch");
                                           }
                                           if(i>=attr.Count){
                                             SemErr("Incorrect number of arguments");
                                           }
                                            program.Add(new Instruction("", "StoG " + (structI)));
                                            structI--; 
                                            i++;
                             .)
                 |(. program.Add(new Instruction("", "Const " + (structI)));.)
                   Str<sym,out type>  (.  
                                              if(i>=attr.Count){
                                                 SemErr("Incorrect number of arguments");
                                               }
                                               
                                               structI--;
                                               i++;
                                            .)
           )
     
     }

   
   ")" ';'
.

/*------------------------------------------------------------------------*/
ConstDecl            (.
                                    string name; string sval; Symbol sym; TastierType type; TastierType etype; Scope currentScope = openScopes.Peek(); bool external=false; int addr=0;
                                .)
= "const"
  Type<out type>
  Ident<out name>               (. 
                                       
                                      currentScope.Push(sym=new Symbol(name, (int)TastierKind.Const, (int)type, openScopes.Count-1, globalDec));
                                      globalDec++;
                                     
                                .) 

  ":="
  ( 
    | Expr<out etype> 
    (  ['?'         //conditional operations         
         (.
                                    if ((TastierType)etype != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                  
                                .)
    Expr<out etype>         (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    /*
                                       If we got into the "if", we need to
                                       jump over the "else" so that it
                                       doesn't get executed.
                                    */
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)
    
     ':' Expr<out etype>         (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .)
  
  
                           
     ]         (.
                                    sym = lookup(openScopes, name);
                                    if (etype != type) {
                                      SemErr("incompatible types");
                                    }
                                    if ((openScopes.Count-1) == 0) {
                                      if (external) {
                                        program.Add(new Instruction("", "StoG " + name));
                                        // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                      } else {
                                         
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                       
                                      }
                                    }
                                    else {
                                        SemErr("Consts must be in global scope");
                                    }
                                .)
                
    )
  | Str<sym,out type>            )        //string declarations
  ';'.
/*------------------------------------------------------------------------*/

/*
   Arrays strings and structs are considered global variables
*/ 
VarDecl<bool external>           (.
                                    string name; TastierType type; Scope currentScope = openScopes.Peek();Symbol sym;int mSize;List<int> dimnS = new List<int> ();
                                  Symbol sym;
                                 .)
= Type<out type>
     ( 
        
         Ident<out name>          (. 
                                      if (external) {
                                        externalDeclarations.Push(new Symbol(name, (int)TastierKind.Var, (int)type, 0, 0));
                       
                                      } else {
                                        
                                        if (((openScopes.Count-1) > 0) && (type != TastierType.String))
                                        {                                       
                                          sym=new Symbol(name, (int)TastierKind.Var, (int)type, openScopes.Count-1, ( currentScope.Count(s => (s.Item2 == (int)TastierKind.Var) || (s.Item2 == (int)TastierKind.Const)
                                            || (s.Item2 == (int)TastierKind.Array)||(s.Item2 == (int)TastierKind.Struct) )));
                                        }
                                        else
                                        { // for global variables
                                           
                                           sym=new Symbol(name, (int)TastierKind.Var, (int)type, 0,  globalDec );
                                        
                                             
                                          
                                        }
                                      }
                                  .)
        [  
         '[' number                  (.  
                                            mSize=Convert.ToInt32(t.val);
                                            dimnS.Add(Convert.ToInt32(t.val));

                                         .)
           ']'
           {'['number                  (.  
                                            mSize*=Convert.ToInt32(t.val);
                                            dimnS.Add(Convert.ToInt32(t.val));

                                         .)           
           ']'}
                                       (.    
                                          sym=new Symbol(name, (int)TastierKind.Array, (int)type, 0,  globalDec );
                                          program.Add(new Instruction("", "Const " + statAddr)); // store the start address of the array
                                          program.Add(new Instruction("", "StoG " + (globalDec+3)));
                                          
                                          
                                          arrSymbolInfo.Add(sym.Item5,dimnS);
                                           
                                          statAddr=statAddr- mSize ; 
                                              
                                           
                                     .)

        ](.
             if(sym.Item4==0){// if declared as global
               globalDec++;  
             }
             currentScope.Push(sym); 
           .)
     
      

    { ',' Ident<out name>          (. 
                                      if (external) {
                                        externalDeclarations.Push(new Symbol(name, (int)TastierKind.Var, (int)type, 0, 0));
                       
                                      } else {
                                        
                                        if (((openScopes.Count-1) > 0) && (type != TastierType.String))
                                        {                                       
                                          sym=new Symbol(name, (int)TastierKind.Var, (int)type, openScopes.Count-1, ( currentScope.Count(s => (s.Item2 == (int)TastierKind.Var) || (s.Item2 == (int)TastierKind.Const)
                                            || (s.Item2 == (int)TastierKind.Array)||(s.Item2 == (int)TastierKind.Struct) )));
                                        }
                                        else
                                        { // for global variables
                                           
                                           sym=new Symbol(name, (int)TastierKind.Var, (int)type, 0,  globalDec );
                                        
                                             
                                          
                                        }
                                      }
                                  .)
        [  
         '[' number                  (.  
                                            mSize=Convert.ToInt32(t.val);
                                            dimnS.Add(Convert.ToInt32(t.val));

                                         .)
           ']'
           {'['number                  (.  
                                            mSize*=Convert.ToInt32(t.val);
                                            dimnS.Add(Convert.ToInt32(t.val));

                                         .)           
           ']'}
                                       (.    
                                          sym=new Symbol(name, (int)TastierKind.Array, (int)type, 0,  globalDec );
                                          program.Add(new Instruction("", "Const " + statAddr)); // store the start address of the array
                                          program.Add(new Instruction("", "StoG " + (globalDec+3)));
                                          
                                          
                                          arrSymbolInfo.Add(sym.Item5,dimnS);
                                           
                                          statAddr=statAddr- mSize ; 
                                              
                                           
                                     .)

        ](.
             if(sym.Item4==0){// if declared as global
               globalDec++;  
             }
             currentScope.Push(sym); 
           .)
    } )
';'.


ExternDecl                      (.  string name; bool external = true; Scope currentScope = openScopes.Peek(); int count = currentScope.Count; .)
= "external"
  ( VarDecl<external>
  | "procedure" Ident<out name> ';'
                                (.  externalDeclarations.Push(new Symbol(name, (int)TastierKind.Proc, (int)TastierType.Undefined, 1, -1));Console.WriteLine("Externa3 Variable "+name+ "  " ); .)
  ) .
 
END Tastier.
